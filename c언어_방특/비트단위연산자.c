#include <stdio.h>
main(void) {

	printf("==============비트단위연산자==============\n");
	// & (and) : 대응하는 각 비트의 값이 모두 1이면 1을 반환 아니면 0을 반환
	// | (or) : 대응하는 비트의 값 중 1이 하나라도 있으면 1을 반환
	// ^ (xor) : 대응하는 비트의 값이 다르면 1을 반환
	// ~ (not) : 비트의 값이 1이면 0으로, 0이라면 1로 결과를 반전시켜서 나타냄

	int bitFive = 5;     // 0101
	int bitThree = 3;  // 0011

	// 10진수를 2진수로 바꾸는 방법은 2로 계속 나누고 나머지를 기록한다.
	// 5 / 2 = 2(몫), 1(나머지) | 3 / 2 = 1(몫), 1(나머지)
	// 2 / 2 = 1(몫), 0(나머지) | 1 / 2 = 0(몫), 1(나머지)
	// 1 / 2 = 0(몫), 1(나머지) |
	// 즉 4비트롤 맞추면 사용하면 0101이 되고,0011이 된다
	printf("bitFive & bitThree = %d\n", bitFive & bitThree); // 0001 = 1
	// 두 숫자의 각 비트를 대응하여 AND 연산을 수행합니다.
	// 0101 - 0011 = 0001 : 둘다 1이 들어있는 자리만 1로 표시되는것!
	printf("bitFive | bitThree = %d\n", bitFive | bitThree); // 0111 = 7
	// 2진수를 10진수로 변경하는 방법 : 오른쪽 자리수부터 2의 거듭제곱을 한다.
	// 0111 : 맨 왼쪽부터 값 0 에 2의 인덱스 번호인 3을 제곱해주면 값은 8이 나온다. 0*8은 ? 0
	// 0111 : 두번째 값 1에 2진수의 2와 인덱스 번호인  2를 제곱해주면 4가 나오고 1*4 = 4
	// 0111 : 세번째 값 1에 2진수의 2와 인덱스 번호인  1를 제곱해주면 2가 나오고 1*2 = 2
	// 0111 : 마지막 값 1에 2진수의 2와 인덱스 번호인 0승을 계산하면 구하면 1이 나온다
	// *어떤수 라도 0승이 되면 항상 1이되는거~ 하지만 0의 0승은 정의되지 않죠? 
	// 즉 나온 값인 0 + 4 + 2 + 1 = 7이라는 숫자가 나오게 된다.
	printf("bitFive ^ bitThree = %d\n", bitFive ^ bitThree); //  0110 = 6
	// 위의 7의 값과 마지막 값이 하나만 0으로 다르기 때문에 6임을 계산하지 않아도 알 수 있다.
	int notFive = ~bitFive;
	printf("~%d = %d\n", bitFive, notFive);
	// 8비트로 표현하면 00000101인 5의 비트를 ~not연산을 사용해 모두 반전한다.
	// 1111 1010 이라는 숫자가 나올텐데 반전된 값의 부호비트는 1로 음수를 나타낸다. 
	// 이건  나중에 자세히 공부하기
	return 0;
}